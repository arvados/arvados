
#![allow(dead_code)]
#![allow(non_snake_case)]

use serde_json::Value;
use std::collections::HashMap;
use serde::{Serialize, Deserialize};
use std::rc::Rc;
use reqwest::{Request, Client, Response};
use reqwest::header::{HeaderValue, HeaderMap, AUTHORIZATION};


// This code is generated by the build.rs script and avados-api-generator.
include!(concat!(env!("OUT_DIR"), "/arvados-api.rs"));

impl KeepServicesGetMethodWrapper {
    async fn fetch(&self) -> Result<KeepService> {
        let KeepServicesGetMethodWrapper(ref client, ref method) = self;
        let url = format!("{}keep_services/{}/", client.base_url, method.uuid);
        let ksresp = client.http_client.get(&url).send().await?;
        if ksresp.status() != 200 {
            return Err(format!("{:?}", ksresp).into());
        }
        let text = ksresp.text().await?;
        let res : KeepService = serde_json::from_str(text.as_ref())?;
        Ok(res)
    }
}

#[derive(Debug)]
pub struct ArvadosApi {
    client: Rc<ArvadosClient>,
}

#[derive(Debug)]
pub struct ArvadosClient {
    http_client: Client,
    base_url: String,
}

impl ArvadosApi {
    pub fn new(arv_api_host: &str, arv_api_token: &str, arv_api_host_insecure: bool) -> Result<Self> {
        Ok(ArvadosApi { client: Rc::new(ArvadosClient::new(arv_api_host, arv_api_token, arv_api_host_insecure)?)})
    }
}

type ArvadosError = Box<dyn std::error::Error + Send + Sync>;
pub type Result<T> = std::result::Result<T, ArvadosError>;


impl ArvadosClient {
    pub fn new(arv_api_host: &str, arv_api_token: &str, arv_api_host_insecure: bool) -> Result<Self> {
        let proto = if arv_api_host_insecure { "http" } else {"https" };
        let base_url = format!("{}://{}/arvados/v1/", proto, arv_api_host);
        let mut headers = HeaderMap::new();
        let auth = format!("OAuth2 {}", arv_api_token);
        headers.insert(AUTHORIZATION, HeaderValue::from_str(auth.as_ref())?);
        let http_client = Client::builder().default_headers(headers).build()?;
        Ok(Self { http_client, base_url })
    }

    pub fn http_client(&self) -> &Client {
        &self.http_client
    }
}



#[cfg(test)]
mod tests {
    use super::*;

    use std::convert::Infallible;
    use std::net::SocketAddr;
    use hyper::service::{make_service_fn, service_fn};
    
    async fn mock_handler(req: hyper::Request<hyper::Body>) -> std::result::Result<hyper::Response<hyper::Body>, Infallible> {
        eprintln!("in handle {:?}", req);
        match (req.method(), req.uri().path()) {
            (&reqwest::Method::GET, "/arvados/v1/keep_services/xyz/") => Ok(hyper::Response::new(hyper::Body::from(r#"{ "etag": "12345" }"#))),
            _ => Ok(hyper::Response::builder().status(hyper::StatusCode::NOT_FOUND).body(hyper::Body::from("{}")).unwrap())
        }
    }
    
    #[tokio::test]
    async fn test_keep_services_get() {
        // TODO: use an ephemeral port
        let addr = SocketAddr::from(([127, 0, 0, 1], 3000));
    
        let make_service = make_service_fn(|_conn| async {
            Ok::<_, Infallible>(service_fn(mock_handler))
        });
    
        // server will make a service on every new connection
        let server = hyper::Server::bind(&addr).serve(make_service);
    
        // run the server until the queries have finished.
        let e = server.with_graceful_shutdown(
            async {
                let arv_api_host = "localhost:3000";
                let arv_api_token = "token";
                let arv_api_host_insecure = true;

                let arvados = ArvadosApi::new(arv_api_host, arv_api_token, arv_api_host_insecure).unwrap();
                let resp = arvados.keep_services().get("xyz".to_string()).fetch().await;
                assert_eq!(format!("{:?}", resp), "Ok(KeepService { owner_uuid: None, etag: Some(\"12345\"), modified_by_client_uuid: None, service_port: None, service_type: None, read_only: None, created_at: None, uuid: None, modified_at: None, service_host: None, modified_by_user_uuid: None, service_ssl_flag: None, updated_at: None })");
            }
        ).await;
    }
}
